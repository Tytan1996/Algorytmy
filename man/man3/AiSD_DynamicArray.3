.TH "AiSD::DynamicArray" 3 "Thu Mar 17 2022" "Tablica Dynamiczna" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AiSD::DynamicArray
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBDynamicArray\fP ()"
.br
.RI "Ta metoda jest konstruktorem, ktora ustawia parametry poczatkowe\&. "
.ti -1c
.RI "\fBDynamicArray\fP (size_t rozmiar)"
.br
.RI "Te konstuktory dzialaja jak wedlug instrukcji\&. "
.ti -1c
.RI "\fBDynamicArray\fP (size_t rozmiar, size_t N, const T &t)"
.br
.ti -1c
.RI "\fBDynamicArray\fP (const \fBDynamicArray\fP &dynamicArray1)"
.br
.RI "Te konstuktory dodatkowe z * dzialaja\&. "
.ti -1c
.RI "\fBDynamicArray\fP (\fBDynamicArray\fP &&dynamicArray)"
.br
.ti -1c
.RI "\fBDynamicArray\fP & \fBoperator=\fP (const \fBDynamicArray\fP other)"
.br
.ti -1c
.RI "\fBDynamicArray\fP & \fBoperator=\fP (\fBDynamicArray\fP &dynamicArray)"
.br
.ti -1c
.RI "virtual \fB~DynamicArray\fP ()"
.br
.RI "Te destruktor usuwa dynamiczna tablice;\&. "
.ti -1c
.RI "void \fBPrint\fP ()"
.br
.RI "Ta metoda pokazuje zawartsc tablicy\&. "
.ti -1c
.RI "void \fBSave\fP ()"
.br
.RI "Ta metoda zapisuje do pliku\&. "
.ti -1c
.RI "bool \fBIsEmpty\fP ()"
.br
.RI "Ta metoda dziala zgodnie jak wedlug instrukcji w czasie O(1) "
.ti -1c
.RI "bool \fBIsFull\fP ()"
.br
.RI "Ta metoda dziala zgodnie jak wedlug instrukcji w czasie O(1) "
.ti -1c
.RI "size_t \fBSpace\fP ()"
.br
.RI "Ta metoda dziala zgodnie jak wedlug instrukcji w czasie O(1) "
.ti -1c
.RI "void \fBPushBack\fP (T t)"
.br
.RI "Ta metoda dziala zgodnie jak wedlug instrukcji w czasie O(1) Jesli zakres tablicy jest przepelniony to czas jest troche inny\&. "
.ti -1c
.RI "void \fBPopBack\fP ()"
.br
.RI "Ta metoda dziala zgodnie jak wedlug instrukcji w czasie O(1) "
.ti -1c
.RI "void \fBPushFront\fP (T t)"
.br
.RI "Ta metoda dziala zgodnie jak wedlug instrukcji w czasie O(size) Jesli zakres tablicy jest przepelniony to czas jest troche inny\&. "
.ti -1c
.RI "void \fBPopFront\fP ()"
.br
.RI "Ta metoda dziala zgodnie jak wedlug instrukcji w czasie O(size) "
.ti -1c
.RI "void \fBInsert\fP (T t, size_t i)"
.br
.RI "Ta metoda dziala zgodnie jak wedlug instrukcji w czasie O(size) "
.ti -1c
.RI "void \fBErase\fP (size_t i)"
.br
.RI "Ta metoda dziala zgodnie jak wedlug instrukcji w czasie O(size) "
.ti -1c
.RI "T & \fBoperator[]\fP (size_t i)"
.br
.RI "Ten przeciazony operator dziala tak samo jak dla tablic\&. "
.ti -1c
.RI "void \fBClear\fP ()"
.br
.RI "Ta metoda (dodatkowa) dziala zgodnie jak wedlug instrukcji w czasie O(size) "
.ti -1c
.RI "size_t \fBSearch\fP (const T &t)"
.br
.RI "Ta metoda (dodatkowa) dziala zgodnie jak wedlug instrukcji w czasie O(size) "
.ti -1c
.RI "bool \fBEraseFirst\fP (const T &t)"
.br
.RI "Ta metoda (dodatkowa) dziala zgodnie jak wedlug instrukcji w czasie O(size) "
.ti -1c
.RI "size_t \fBEraseAll\fP (const T &t)"
.br
.RI "Ta metoda (dodatkowa) dziala zgodnie jak wedlug instrukcji NIE w czasie O(size) "
.ti -1c
.RI "size_t \fBErase\fP (size_t from, size_t to)"
.br
.RI "Ta metoda (dodatkowa) dziala zgodnie jak wedlug instrukcji w NIE JESTEM PEWNY czasie O(size) "
.ti -1c
.RI "void \fBRead\fP ()"
.br
.RI "Ten operator czyta plik z wartosciami tablic;\&. "
.ti -1c
.RI "void \fBPowiekszanieTablicy\fP ()"
.br
.RI "Ta metoda (dodatkowa) dziala poprawnie\&. "
.ti -1c
.RI "T & \fBat\fP (size_t i)"
.br
.RI "Ta metoda (dodatkowa) dziala zgodnie jak w isntrukcji w czasie O(1) "
.ti -1c
.RI "void \fBInsert\fP (T t, size_t iloscElementow, size_t i)"
.br
.RI "Ta metoda (dodatkowa z *) dodaje na pozycji 'i' tyle elementow t ile jest nadanie w operacji\&. "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "auto \fBDoFunction\fP (\fBDynamicArray\fP &, int, T, size_t)"
.br
.RI "Ta funkcja wykonuje funkcje Dynamic Array, gdzie NO to numer funkcji od 0\&. Zapisje wszystkie operacje do pliku (LogFileName 'Log\&.txt') na wypadek crashu\&. Mierzy takze czas wykonywania operacji w mikrosekundach\&. Zwraca variant<bool,size_t,noneV (nothing)> (jako to co pierwotna funkcja Dynamic Array nam zwracala) "
.ti -1c
.RI "void \fBOverflowTable\fP (\fBDynamicArray\fP &)"
.br
.RI "Wykonuje te same funkcje Dynamic Array do pusta i pelna\&. Pesymistyczny scenariusz jest taki, ze przyjmujemy zawsze te najwieksze liczby jakie moge wprowadzic\&. Mierzy czas dla funkcji powtarzanej tyle razy jaka jest wielkosc tablicy\&. Przy okazji testuje takie sytuacje kiedy dodajemy kolejny element do pelnej tablicy oraz usuwamy element z pustej tablicy\&. Robi to poza mierzeniem czasu\&. Zmierzony czas jest w mikrosekundach i wyswietla sie na ekranie\&. "
.in -1c
.SH "Friends And Related Function Documentation"
.PP 
.SS "auto DoFunction (\fBDynamicArray\fP &, int, T, size_t)\fC [friend]\fP"

.PP
Ta funkcja wykonuje funkcje Dynamic Array, gdzie NO to numer funkcji od 0\&. Zapisje wszystkie operacje do pliku (LogFileName 'Log\&.txt') na wypadek crashu\&. Mierzy takze czas wykonywania operacji w mikrosekundach\&. Zwraca variant<bool,size_t,noneV (nothing)> (jako to co pierwotna funkcja Dynamic Array nam zwracala) 
.PP
\fBParameters\fP
.RS 4
\fIarr\fP Dynamic Array 
.br
\fINO\fP Numer funkcji Dynamic Array od 0 
.br
\fIt\fP Pierwszy parametr funkcji Dynamic Array 
.br
\fIi\fP Drugi parametr funkcji Dynamic Array 
.RE
.PP

.SS "void OverflowTable (\fBDynamicArray\fP &)\fC [friend]\fP"

.PP
Wykonuje te same funkcje Dynamic Array do pusta i pelna\&. Pesymistyczny scenariusz jest taki, ze przyjmujemy zawsze te najwieksze liczby jakie moge wprowadzic\&. Mierzy czas dla funkcji powtarzanej tyle razy jaka jest wielkosc tablicy\&. Przy okazji testuje takie sytuacje kiedy dodajemy kolejny element do pelnej tablicy oraz usuwamy element z pustej tablicy\&. Robi to poza mierzeniem czasu\&. Zmierzony czas jest w mikrosekundach i wyswietla sie na ekranie\&. 
.PP
\fBParameters\fP
.RS 4
\fIarr\fP Dynamic Array 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Tablica Dynamiczna from the source code\&.
